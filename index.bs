<pre class=metadata>
Title: Native File System
Shortname: native-file-system
Abstract: This document defines a web platform API that lets websites gain write access to the
  native file system. It builds on [[FILE-API|File API]], but adds lots of new functionality on top.
Status: CG-DRAFT
ED: https://wicg.github.io/native-file-system/
Level: 1
Editor: Marijn Kruisselbrink, Google, mek@chromium.org, w3cid 72440
Group: WICG
Repository: wicg/native-file-system
Indent: 2
Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: css no, markdown yes
</pre>

<pre class=link-defaults>
spec:fetch; type:interface; text:ReadableStream
spec:webidl; type:dfn; text:resolve
</pre>

<pre class=anchors>
</pre>

<style>
.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
.domintro dt a {
    color: inherit; border-bottom-style: none;
}
.domintro dt code {
    font-size: inherit;
}
</style>

# Introduction # {#introduction}

*This section is non-normative.*

TODO

This provides similar functionality as earlier drafts of the
[[file-system-api|File API: Directories and System]] as well as the
[[entries-api|File and Directory Entries API]], but with a more modern API.

# Files and Directories # {#files-and-directories}

## Concepts ## {#concepts}

An <dfn>entry</dfn> is either a [=file entry=] or a [=directory entry=].

Each [=/entry=] has an associated <dfn for=entry>name</dfn>.

A <dfn lt="file|file entry">file entry</dfn> additionally consists of <dfn for="file entry">binary
data</dfn> and a <dfn for="file entry">modification timestamp</dfn>.

A <dfn lt="directory|directory entry">directory entry</dfn> additionally consists of a [=/set=] of
<dfn for="directory entry">children</dfn>, which are themselves [=/entries=]. Each member is either a [=/file=] or a [=directory=].

An [=/entry=] |entry| should be [=list/contained=] in the [=children=] of at most one
[=directory entry=], and that directory entry is also known as |entry|'s <dfn for=entry>parent</dfn>.
An [=/entry=]'s [=entry/parent=] is null if no such directory entry exists.

Note: Two different [=/entries=] can represent the same file or directory on disk, in which
case it is possible for both entries to have a different parent, or for one entry to have a
parent while the other entry does not have a parent. Typically an entry does not have a parent
if it was returned by {{chooseFileSystemEntries()}} or {{getSystemDirectory()}}, and an entry
will have a parent in all other cases.

[=/Entries=] can (but don't have to) be backed by files on the systems native file system,
so it is possible for the [=binary data=], [=modification timestamp=],
and [=children=] of entries to be modified by applications outside of this specification.
Exactly how external changes are reflected in the data structures defined by this specification,
as well as how changes made to the data structures defined here are reflected externally
is left up to individual user-agent implementations.

An [=/entry=] |a| is <dfn for="entry">the same as</dfn> an [=/entry=] |b| if |a| is equal to |b|, or
if |a| and |b| are backed by the same file or directory on the native file system.

Issue: TODO: Explain better how entries map to files on disk (multiple entries can map to the same file or
directory on disk but an entry doesn't have to map to any file on disk).

<div algorithm>
To <dfn for="entry">resolve</dfn> an [=/entry=] |child| relative to a [=directory entry=] |root|,
run the following steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. If |child| is [=the same as=] |root|,
     [=/resolve=] |result| with an empty list, and abort.
  1. Let |childPromises| be « ».
  1. [=set/For each=] |entry| of |root|'s [=FileSystemHandle/entry=]'s [=children=]:
    1. Let |p| be the result of [=entry/resolving=] |child| relative to |entry|.
    1. [=list/Append=] |p| to |childPromises|.
    1. [=Upon fulfillment=] of |p| with value |path|:
      1. If |path| is not null:
        1. [=list/Prepend=] |entry|'s [=entry/name=] to |path|.
        1. [=/Resolve=] |result| with |path|.
  1. [=Wait for all=] |childPromises|, with the following success steps:
    1. If |result| hasn't been resolved yet, [=/resolve=] |result| with `null`.
1. Return |result|.

</div>

## Permissions ## {#permissions}

Issue: Figure out some way to integrate this better with the permissions API [[permissions]],
for example by making the entry be a part of the PermissionDescriptor.

<div algorithm>
An [=/entry=] |entry| has associated <dfn for=entry>query permission steps</dfn>,
which take a {{FileSystemHandlePermissionDescriptor}} and return a {{PermissionState}}.
Unless specified otherwise, these steps are:
1. Let |parent| be |entry|'s [=entry/parent=].
1. Assert: |parent| is not null.

   Note: [[#native-file-system-permissions]] overrides these steps for entries returned by
   {{chooseFileSystemEntries()}}. Additionally [[#special-filesystem-concepts]] overrides
   these steps for entries returned by {{FileSystemDirectoryHandle/getSystemDirectory()}}.
   All other entries always have a parent.

1. Return the result of running |parent|'s [=query permission steps=].

Note: These steps return the current state synchronously, however these steps are only
invoked from "in parallel" sections of algorithms, so this doesn't have to be implemented
in a synchronous manner.
</div>

<div algorithm>
An [=/entry=] |entry| also has associated <dfn for=entry>request permission steps</dfn>,
which take a {{FileSystemHandlePermissionDescriptor}}.
Unless specified otherwise, these steps are:
1. Let |parent| be |entry|'s [=entry/parent=].
1. If |parent| is not null, run |parent|'s [=request permission steps=].

Note: These steps do not return anything. However as a result of executing the request
permission steps for an entry the permission state for that entry (and other entries)
can be updated, and the new state can be queried by executing the query permission steps.
</div>

## The {{FileSystemHandle}} interface ## {#api-filesystemhandle}

<xmp class=idl>
dictionary FileSystemHandlePermissionDescriptor {
  boolean writable = false;
};

[Exposed=(Window,Worker), SecureContext, Serializable]
interface FileSystemHandle {
  readonly attribute boolean isFile;
  readonly attribute boolean isDirectory;
  readonly attribute USVString name;

  Promise<boolean> isSameEntry(FileSystemHandle other);

  Promise<PermissionState> queryPermission(optional FileSystemHandlePermissionDescriptor descriptor = {});
  Promise<PermissionState> requestPermission(optional FileSystemHandlePermissionDescriptor descriptor = {});
};
</xmp>

A {{FileSystemHandle}} object represents an [=/entry=]. Each {{FileSystemHandle}} object is associated
with an <dfn for=FileSystemHandle>entry</dfn> (an [=/entry=]). Multiple separate objects implementing
the {{FileSystemHandle}} interface can all be associated with the same [=/entry=] simultaneously.

<div algorithm="serialization steps">
{{FileSystemHandle}} objects are [=serializable objects=].

Advisement: In the Origin Trial as available in Chrome 78, these objects are not yet serializable. 
In Chrome 82 they are.

Their [=serialization steps=], given |value|, |serialized| and |forStorage| are:

1. Set |serialized|.\[[Origin]] to |value|'s [=relevant settings object=]'s [=environment settings object/origin=].
1. Set |serialized|.\[[Entry]] to |value|'s [=FileSystemHandle/entry=].

</div>

<div algorithm="deserialization steps">
Their [=deserialization steps=], given |serialized| and |value| are:

1. If |serialized|.\[[Origin]] is not [=same origin=] with
   |value|'s [=relevant settings object=]'s [=environment settings object/origin=],
   then throw a {{DataCloneError}}.
1. Set |value|'s [=FileSystemHandle/entry=] to |serialized|.\[[Entry]]

</div>

<div class="note domintro">
  : |handle| . {{FileSystemHandle/isFile}}
  :: Returns true if |handle| is a {{FileSystemFileHandle}}.

  : |handle| . {{FileSystemHandle/isDirectory}}
  :: Returns true if |handle| is a {{FileSystemDirectoryHandle}}.

  : |handle| . {{FileSystemHandle/name}}
  :: Returns the [=entry/name=] of the entry represented by |handle|.
</div>

The <dfn attribute for=FileSystemHandle>isFile</dfn> attribute must return true if the associated
[=FileSystemHandle/entry=] is a [=file entry=], and false otherwise.

The <dfn attribute for=FileSystemHandle>isDirectory</dfn> attribute must return true if the
associated [=FileSystemHandle/entry=] is a [=directory entry=], and false otherwise.

The <dfn attribute for=FileSystemHandle>name</dfn> attribute must return the [=entry/name=] of the
associated [=FileSystemHandle/entry=].

### The {{FileSystemHandle/isSameEntry()}} method ### {#api-filesystemhandle-issameentry}

<div class="note domintro">
  : |same| = await |handle1| . {{FileSystemHandle/isSameEntry()|isSameEntry}}( |handle2| )
  :: Returns true if |handle1| and |handle2| represent the same file or directory.
</div>

Advisement: This method is first available in Chrome 82.

<div algorithm>
The <dfn method for=FileSystemHandle>isSameEntry(|other|)</dfn> method, when invoked, must run these steps:

1. Let |realm| be [=this=]'s [=relevant Realm=].
1. Let |p| be [=a new promise=] in |realm|.
1. Run the following steps [=in parallel=]:
  1. If [=this=]'s [=FileSystemHandle/entry=] is [=the same as=] |other|'s [=FileSystemHandle/entry=],
     [=/resolve=] |p| with `true`.
  1. Else [=/resolve=] |p| with `false`.
1. Return |p|.

</div>

### The {{FileSystemHandle/queryPermission()}} method ### {#api-filesystemhandle-querypermission}

Issue(119): the currently described API here assumes a model where it is not possible to have a
    write-only handle. I.e. it is not possible to have or request write access without also having
    read access. There definitely are use cases for write-only handles (e.g. directory downloads),
    so we might have to reconsider this.

<div class="note domintro">
  : |status| = await |handle| . {{FileSystemHandle/queryPermission()|queryPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = false })
  : |status| = await |handle| . {{FileSystemHandle/queryPermission()}}
  :: Queries the current state of the read permission of this handle. If this returns `"prompt"`
     the website will have to call {{FileSystemHandle/requestPermission()}} before any
     operations on the handle can be done. If this returns `"denied"` any operations will reject.

     Usually handles returned by {{chooseFileSystemEntries}} will initially return `"granted"` for
     their read permission state, however other than through the user revoking permission, a handle
     retrieved from IndexedDB is also likely to return `"prompt"`.

  : |status| = await |handle| . {{FileSystemHandle/queryPermission()|queryPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = true })
  :: Queries the current state of the write permission of this handle. If this returns `"prompt"`,
     attempting to modify the file or directory this handle represents will require user activation
     and will result in a confirmation prompt being shown to the user. However if the state of the
     read permission of this handle is also `"prompt"` the website will need to call
     {{FileSystemHandle/requestPermission()}}. There is no automatic prompting for read access when
     attempting to read from a file or directory.
</div>

<div algorithm>
The <dfn method for=FileSystemHandle>queryPermission(|descriptor|)</dfn> method, when invoked, must run these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. [=/Resolve=] |result| with the result of running
     <b>[=this=]</b>'s [=FileSystemHandle/entry=]'s [=query permission steps=] given |descriptor|.
1. Return |result|.

</div>

### The {{FileSystemHandle/requestPermission()}} method ### {#api-filesystemhandle-requestpermission}

<div class="note domintro">
  : |status| = await |handle| . {{FileSystemHandle/requestPermission()|requestPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = false })
  : |status| = await |handle| . {{FileSystemHandle/requestPermission()}}
  :: If the state of the read permission of this handle is anything other than `"prompt"`, this
     will return that state directly. If it is `"prompt"` however, user activation is needed and
     this will show a confirmation prompt to the user. The new read permission state is then
     returned, depending on the user's response to the prompt.

  : |status| = await |handle| . {{FileSystemHandle/requestPermission()|requestPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = true })
  :: If the state of the write permission of this handle is anything other than `"prompt"`, this
     will return that state directly. If the status of the read permission of this handle is
     `"denied"` this will return that.

     Otherwise the state of the write permission is `"prompt"` and this will show a confirmation
     prompt to the user. The new write permission state is then returned, depending on what the user
     selected.
</div>

<div algorithm>
The <dfn method for=FileSystemHandle>requestPermission(|descriptor|)</dfn> method, when invoked, must run these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. Run <b>[=this=]</b>'s [=FileSystemHandle/entry=]'s [=request permission steps=] given |descriptor|.
     If that throws an exception, [=reject=] |result| with that exception and abort.
  1. [=/Resolve=] |result| with the result of running
     <b>[=this=]</b>'s [=FileSystemHandle/entry=]'s [=query permission steps=] given |descriptor|.
1. Return |result|.

</div>

## The {{FileSystemFileHandle}} interface ## {#api-filesystemfilehandle}

<xmp class=idl>
dictionary FileSystemCreateWritableOptions {
  boolean keepExistingData = false;
};

[Exposed=(Window,Worker), SecureContext, Serializable]
interface FileSystemFileHandle : FileSystemHandle {
  Promise<File> getFile();
  Promise<FileSystemWritableFileStream> createWritable(optional FileSystemCreateWritableOptions options = {});
};
</xmp>

A {{FileSystemFileHandle}}'s associated [=FileSystemHandle/entry=] must be a [=file entry=].

{{FileSystemFileHandle}} objects are [=serializable objects=]. Their [=serialization steps=] and
[=deserialization steps=] are the same as those for {{FileSystemHandle}}.

Advisement: In the Origin Trial as available in Chrome 78, these objects are not yet serializable. 
In Chrome 82 they are.

### The {{FileSystemFileHandle/getFile()}} method ### {#api-filesystemfilehandle-getfile}

<div class="note domintro">
  : |file| = await |fileHandle| . {{FileSystemFileHandle/getFile()}}
  :: Returns a {{File}} representing the state on disk of the entry represented by |handle|.
     If the file on disk changes or is removed after this method is called, the returned
     {{File}} object will likely be no longer readable.
</div>

<div algorithm>
The <dfn method for=FileSystemFileHandle>getFile()</dfn> method, when invoked, must run these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. Let |permissionStatus| be the result of running
     <b>[=this=]</b>'s [=FileSystemHandle/entry=]'s [=query permission steps=] given
     «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `false`&nbsp;]».
  1. If |permissionStatus| is not {{PermissionState/"granted"}},
     reject |result| with a {{NotAllowedError}} and abort.
  1. TODO
1. Return |result|.

</div>

### The {{FileSystemFileHandle/createWritable()}} method ### {#api-filesystemfilehandle-createwritable}

Advisement: In the Origin Trial as available in Chrome 82, createWritable replaces the createWriter method.

<div class="note domintro">
  : |stream| = await |fileHandle| . {{FileSystemFileHandle/createWritable()}}
  : |stream| = await |fileHandle| . {{FileSystemFileHandle/createWritable()|createWritable}}({ {{FileSystemCreateWritableOptions/keepExistingData}}: true/false })
  :: Returns a {{FileSystemWritableFileStream}} that can be used to write to the file. Any changes made through
     |stream| won't be reflected in the file represented by |fileHandle| until the stream has been closed.
     User agents try to ensure that no partial writes happen, i.e. the file represented by
     |fileHandle| will either contains its old contents or it will contain whatever data was written
     through |stream| up until the stream has been closed.

     This is typically implemented by writing data to a temporary file, and only replacing the file
     represented by |fileHandle| with the temporary file when the writable filestream is closed.

     If {{FileSystemCreateWritableOptions/keepExistingData}} is `false` or not specified,
     the temporary file starts out empty,
     otherwise the existing file is first copied to this temporary file.
</div>

Issue(67): There has been some discussion around and desire for a "inPlace" mode for createWritable
(where changes will be written to the actual underlying file as they are written to the writer, for
example to support in-place modification of large files or things like databases). This is not
currently implemented in Chrome. Implementing this is currently blocked on figuring out how to
combine the desire to run malware checks with the desire to let websites make fast in-place
modifications to existing large files.

<div algorithm>
The <dfn method for=FileSystemFileHandle>createWritable(|options|)</dfn> method, when invoked, must run these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. Let |entry| be <b>[=this=]</b>'s [=FileSystemHandle/entry=].
  1. Run |entry|'s [=request permission steps=] given
     «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
     If that throws an exception, [=reject=] |result| with that exception and abort.
  1. Let |permissionStatus| be the result of running
     |entry|'s [=query permission steps=] given
     «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
  1. If |permissionStatus| is not {{PermissionState/"granted"}},
     reject |result| with a {{NotAllowedError}} and abort.
  1. Let |stream| be the result of [=create a new FileSystemWritableFileStream|creating a new FileSystemWritableFileStream=]
     for |entry|.
  1. If |options|.{{FileSystemCreateWritableOptions/keepExistingData}} is `true`:
    1. Set |stream|.[=[[buffer]]=] to a copy of |entry|'s [=file entry/binary data=].
  1. [=/Resolve=] |result| with |stream|.
1. Return |result|.

</div>

## The {{FileSystemDirectoryHandle}} interface ## {#api-filesystemdirectoryhandle}

<xmp class=idl>
dictionary FileSystemGetFileOptions {
  boolean create = false;
};

dictionary FileSystemGetDirectoryOptions {
  boolean create = false;
};

dictionary FileSystemRemoveOptions {
  boolean recursive = false;
};

[Exposed=(Window,Worker), SecureContext, Serializable]
interface FileSystemDirectoryHandle : FileSystemHandle {
  Promise<FileSystemFileHandle> getFile(USVString name, optional FileSystemGetFileOptions options = {});
  Promise<FileSystemDirectoryHandle> getDirectory(USVString name, optional FileSystemGetDirectoryOptions options = {});

  // This really returns an async iterable, but that is not yet expressable in WebIDL.
  object getEntries();

  Promise<void> removeEntry(USVString name, optional FileSystemRemoveOptions options = {});

  Promise<sequence<USVString>?> resolve(FileSystemHandle possibleDescendant);
};
</xmp>

A {{FileSystemDirectoryHandle}}'s associated [=FileSystemHandle/entry=] must be a [=directory entry=].

{{FileSystemDirectoryHandle}} objects are [=serializable objects=]. Their [=serialization steps=] and
[=deserialization steps=] are the same as those for {{FileSystemHandle}}.

Advisement: In the Origin Trial as available in Chrome 78, these objects are not yet serializable. 
In Chrome 82 they are.

Issue: Should we have separate getFile and getDirectory methods, or just a single getChild/getEntry
method?

Issue(98): Having getFile methods in both FileSystemDirectoryHandle and FileSystemFileHandle, but
with very different behavior might be confusing? Perhaps rename at least one of them (but see also
previous issue).

Issue(47): Should getEntries be its own method, or should FileSystemDirectoryHandle just be an async
iterable itself?

### The {{FileSystemDirectoryHandle/getFile()}} method ### {#api-filesystemdirectoryhandle-getfile}

<div class="note domintro">
  : |fileHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getFile()|getFile}}(|name|)
  : |fileHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getFile()|getFile}}(|name|, { {{FileSystemGetFileOptions/create}}: false })
  :: Returns a handle for a file named |name| in the directory represented by |directoryHandle|. If
     no such file exists, this rejects.

  : |fileHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getFile()|getFile}}(|name|, { {{FileSystemGetFileOptions/create}}: true })
  :: Returns a handle for a file named |name| in the directory represented by |directoryHandle|. If
     no such file exists, this creates a new file. If no file with named |name| can be created this
     rejects. Creation can fail because there already is a directory with the same name, because the
     name uses characters that aren't supported in file names on the underlying file system, or
     because the user agent for security reasons decided not to allow creation of the file.

     This operation requires write permission, even if the file being returned already exists. If
     this handle doesn't already have write permission, this could result in a prompt being shown to
     the user. To get an existing file without needing write permission, call this method
     with <code>{ {{FileSystemGetFileOptions/create}}: false }</code>.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getFile(|name|, |options|)</dfn> method, when invoked,
must run these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. Let |entry| be <b>[=this=]</b>'s [=FileSystemHandle/entry=].
  1. If |options|.{{FileSystemGetFileOptions/create}} is `true`:
    1. Run |entry|'s [=request permission steps=] given
       «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
       If that throws an exception, [=reject=] |result| with that exception and abort.
    1. Let |permissionStatus| be the result of running
       |entry|'s [=query permission steps=] given
       «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
  1. Otherwise:
    1. Let |permissionStatus| be the result of running
       |entry|'s [=query permission steps=] given
       «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `false`&nbsp;]».
  1. If |permissionStatus| is not {{PermissionState/"granted"}},
     reject |result| with a {{NotAllowedError}} and abort.
  1. TODO
1. Return |result|.

</div>

### The {{FileSystemDirectoryHandle/getDirectory()}} method ### {#api-filesystemdirectoryhandle-getdirectory}

<div class="note domintro">
  : |subdirHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getDirectory()|getDirectory}}(|name|)
  : |subdirHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getDirectory()|getDirectory}}(|name|, { {{FileSystemGetDirectoryOptions/create}}: false })
  :: Returns a handle for a directory named |name| in the directory represented by
    |directoryHandle|. If no such directory exists, this rejects.

  : |subdirHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getDirectory()|getDirectory}}(|name|, { {{FileSystemGetDirectoryOptions/create}}: true })
  :: Returns a handle for a directory named |name| in the directory represented by
     |directoryHandle|. If no such directory exists, this creates a new directory. If creating the
     directory failed, this rejects. Creation can fail because there already is a file with the same
     name, or because the name uses characters that aren't supported in file names on the underlying
     file system.

     This operation requires write permission, even if the directory being returned already exists.
     If this handle doesn't already have write permission, this could result in a prompt being shown
     to the user. To get an existing directory without needing write permission, call this method
     with <code>{ {{FileSystemGetDirectoryOptions/create}}: false }</code>.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getDirectory(|name|, |options|)</dfn> method, when
invoked, must run these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. Let |entry| be <b>[=this=]</b>'s [=FileSystemHandle/entry=].
  1. If |options|.{{FileSystemGetDirectoryOptions/create}} is `true`:
    1. Run |entry|'s [=request permission steps=] given
       «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
       If that throws an exception, [=reject=] |result| with that exception and abort.
    1. Let |permissionStatus| be the result of running
       |entry|'s [=query permission steps=] given
       «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
  1. Else:
    1. Let |permissionStatus| be the result of running
       |entry|'s [=query permission steps=] given
       «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `false`&nbsp;]».
  1. If |permissionStatus| is not {{PermissionState/"granted"}},
     reject |result| with a {{NotAllowedError}} and abort.
  1. TODO
1. Return |result|.

</div>

### The {{FileSystemDirectoryHandle/getEntries()}} method ### {#api-filesystemdirectoryhandle-getentries}

<div class="note domintro">
  : for await (const |handle| of |directoryHandle| . {{FileSystemDirectoryHandle/getEntries()}}) {}
  :: Iterates over all entries whose parent is the entry represented by |directoryHandle|.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getEntries()</dfn> method, when invoked, must run
these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. Let |permissionStatus| be the result of running
     <b>[=this=]</b>'s [=FileSystemHandle/entry=]'s [=query permission steps=] given
     «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `false`&nbsp;]».
  1. If |permissionStatus| is not {{PermissionState/"granted"}},
     reject |result| with a {{NotAllowedError}} and abort.
  1. TODO
1. Return |result|.

</div>

### The {{FileSystemDirectoryHandle/removeEntry()}} method ### {#api-filesystemdirectoryhandle-removeentry}

<div class="note domintro">
  : await |directoryHandle| . {{FileSystemDirectoryHandle/removeEntry()|removeEntry}}(|name|)
  : await |directoryHandle| . {{FileSystemDirectoryHandle/removeEntry()|removeEntry}}(|name|, { {{FileSystemRemoveOptions/recursive}}: false })
  :: If the directory represented by |directoryHandle| contains a file named |name|, or an empty
     directory named |name|, this will attempt to delete that file or directory.

     Attempting to delete a file or directory that does not exist is considered success,
     while attempting to delete a non-empty directory will result in a promise rejection.

  : await |directoryHandle| . {{FileSystemDirectoryHandle/removeEntry()|removeEntry}}(|name|, { {{FileSystemRemoveOptions/recursive}}: true })
  :: Removes the entry named |name| in the directory represented by |directoryHandle|.
     If that entry is a directory, its contents will also be deleted recursively.
     recursively.

     Attempting to delete a file or directory that does not exist is considered success.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>removeEntry(|name|, |options|)</dfn> method, when invoked, must run
these steps:

1. Let |result| be [=a new promise=].
1. Run the following steps [=in parallel=]:
  1. Let |entry| be <b>[=this=]</b>'s [=FileSystemHandle/entry=].
  1. Run |entry|'s [=request permission steps=] given
     «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
     If that throws an exception, [=reject=] |result| with that exception.
  1. Let |permissionStatus| be the result of running
     |entry|'s [=query permission steps=] given
     «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
  1. If |permissionStatus| is not {{PermissionState/"granted"}},
     reject |result| with a {{NotAllowedError}} and abort.
  1. TODO
1. Return |result|.


</div>

### The {{FileSystemDirectoryHandle/resolve()}} method ### {#api-filesystemdirectoryhandle-resolve}

<div class="note domintro">
  : |path| = await |directory| . {{FileSystemDirectoryHandle/resolve()|resolve}}( |child| )
  :: If |child| is equal to |directory|, |path| will be an empty array.
  :: If |child| is a direct child of |directory|, |path| will be an array containing |child|'s name.
  :: If |child| is a descendant of |directory|, |path| will be an array containing the names of
     all the intermediate directories and |child|'s name as last element.
  :: Otherwise (|directory| and |child| are not related), |path| will be null.
</div>

Advisement: This method is first available in Chrome 82.

<div class=example id=filesystemdirectoryhandle-resolve-example>
<xmp highlight=js>
// Assume we at some point got a valid directory handle.
const dir_ref = current_project_dir;
if (!dir_ref) return;

// Now get a file reference by showing a file picker:
const file_ref = await self.chooseFileSystemEntries({type: 'openFile'});
if (!file_ref) {
    // User cancelled, or otherwise failed to open a file.
    return;
}

// Check if file_ref exists inside dir_ref:
const relative_path = await dir_ref.resolve(file_ref);
if (relative_path === null) {
    // Not inside dir_ref
} else {
    // relative_path is an array of names, giving the relative path
    // from dir_ref to the file that is represented by file_ref:
    assert relative_path.pop() == file_ref.name;

    let entry = dir_ref;
    for (const name of relative_path) {
        entry = await entry.getDirectory(name);
    }
    entry = await entry.getFile(file_ref.name);

    // Now |entry| will represent the same file on disk as |file_ref|.
    assert await entry.isSameEntry(file_ref) == true;
}
</xmp>
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>resolve(|possibleDescendant|)</dfn> method,
when invoked, must return the result of [=entry/resolving=]
|possibleDescendant|'s [=FileSystemHandle/entry=] relative to [=this=]'s [=FileSystemHandle/entry=].

</div>



## The {{FileSystemWritableFileStream}} interface ## {#api-filesystemwritablefilestream}

<xmp class=idl>
enum WriteCommandType {
  "write",
  "seek",
  "truncate",
};

dictionary WriteParams {
  required WriteCommandType type;
  unsigned long long? size;
  unsigned long long? position;
  (BufferSource or Blob or USVString)? data;
};

typedef (BufferSource or Blob or USVString or WriteParams) FileSystemWriteChunkType;

[Exposed=(Window,Worker), SecureContext]
interface FileSystemWritableFileStream : WritableStream {
  Promise<void> write(FileSystemWriteChunkType data);
  Promise<void> seek(unsigned long long position);
  Promise<void> truncate(unsigned long long size);
};
</xmp>

A {{FileSystemWritableFileStream}} has an associated <dfn for=FileSystemWritableFileStream>\[[file]]</dfn> (a [=file entry=]).

A {{FileSystemWritableFileStream}} has an associated <dfn for=FileSystemWritableFileStream>\[[buffer]]</dfn> (a [=byte sequence=]).
It is initially empty.

Note: This buffer can get arbitrarily large, so it is expected that implementations will not keep this in memory,
but instead use a temporary file for this. All access to \[[buffer]] is done in promise returning methods and
algorithms, so even though operations on it seem sync, implementations can implement them async.

A {{FileSystemWritableFileStream}} has an associated <dfn for=FileSystemWritableFileStream>\[[seekOffset]]</dfn> (a number).
It is initially 0.

<div class="note domintro">
A {{FileSystemWritableFileStream}} object is a {{WritableStream}} object with additional
convenience methods, which operates on a single file on disk.

Upon creation, an underlying sink will have been created and the stream will be usable.
All operations executed on the stream are queuable and producers will be able to respond to backpressure.

The underlying sink's write method, and therefore {{WritableStreamDefaultWriter/write()|WritableStreamDefaultWriter's write()}}
method, will accept byte-like data or {{WriteParams}} as input.

The {{FileSystemWritableFileStream}} has a file position cursor initialized at byte offset 0 from the top of the file.
When using {{FileSystemWritableFileStream/write()|write()}} or by using WritableStream capabilities through the {{WritableStreamDefaultWriter/write()|WritableStreamDefaultWriter's write()}} method, this position will be advanced based on the number of bytes written through the stream object.

Similarly, when piping a {{ReadableStream}} into a {{FileSystemWritableFileStream}} object, this position is updated with the number of bytes that passed through the stream.

{{WritableStream/getWriter()|getWriter()}} returns an instance of {{WritableStreamDefaultWriter}}.
</div>

<div algorithm>
To <dfn>create a new FileSystemWritableFileStream</dfn> given a [=file entry=] |file|, perform the following steps:

1. Let |stream| be a new {{FileSystemWritableFileStream}}.
1. Perform [$InitializeWritableStream$](|stream|)
1. Set |stream|.[=FileSystemWritableFileStream/[[file]]=] to |file|.
1. Let |controller| be a new {{WritableStreamDefaultController}}.
1. Let |startAlgorithm| be an algorithm that returns `undefined`.
1. Let |writeAlgorithm| be an algorithm which takes a |chunk| argument
   and returns the result of running the [=write a chunk=] algorithm with |stream| and |chunk|.
1. Let |closeAlgorithm| be the following steps:
   1. Let |closeResult| be [=a new promise=].
   1. Run the following steps [=in parallel=]:
      1. Let |permissionStatus| be the result of running
         |stream|.[=[[file]]=]'s [=query permission steps=] given
         «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
      1. If |permissionStatus| is not {{PermissionState/"granted"}},
         reject |closeResult| with a {{NotAllowedError}} and abort.
      1. TODO: optional UA defined security checks
      1. Set |stream|.[=[[file]]=]'s [=file entry/binary data=] to |stream|.[=[[buffer]]=].
         If that throws an exception, reject |closeResult| with that exception and abort.

         Note: It is expected that this atomically updates the contents of the file on disk
         being written to.
      1. [=/Resolve=] |closeResult| with `undefined`.
   1. Return |closeResult|.
1. Let |abortAlgorithm| be an algorithm that returns [=a promise resolved with=] `undefined`.
1. Let |highWaterMark| be 1.
1. Let |sizeAlgorithm| be an algorithm that returns `1`.
1. Perform [$SetUpWritableStreamDefaultController$](|stream|, |controller|, |startAlgorithm|, |writeAlgorithm|, |closeAlgorithm|, |abortAlgorithm|, |highWaterMark|, |sizeAlgorithm|).
1. Return |stream|.

</div>

<div algorithm>
The <dfn>write a chunk</dfn> algorithm,
given a {{FileSystemWritableFileStream}} |stream| and |chunk|,
runs these steps:

1. Let |input| be the result of [=converting=] |chunk| to a {{FileSystemWriteChunkType}}.
   If this throws an exception, then return [=a promise rejected with=] that exception.
1. Let |p| be [=a new promise=].
1. Run the following steps [=in parallel=]:
   1. Let |permissionStatus| be the result of running
      |stream|.[=[[file]]=]'s [=query permission steps=] given
      «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `true`&nbsp;]».
   1. If |permissionStatus| is not {{PermissionState/"granted"}},
      reject |p| with a {{NotAllowedError}} and abort.
   1. Let |command| be |input|.{{WriteParams/type}} if |input| is a {{WriteParams}},
      and {{WriteCommandType/"write"}} otherwise.
   1. If |command| is {{WriteCommandType/"write"}}:
      1. Let |data| be |input|.{{WriteParams/data}} if |input| is a {{WriteParams}},
         and |input| otherwise.
      1. If |data| is `undefined`,
         reject |p| with a {{TypeError}} and abort.
      1. Let |writePosition| be |stream|.[=[[seekOffset]]=].
      1. If |input| is a {{WriteParams}} and |input|.{{WriteParams/position}} is not `undefined`,
         set |writePosition| to |input|.{{WriteParams/position}}.
      1. Let |oldSize| be |stream|.[=[[buffer]]=]'s [=byte sequence/length=].
      1. If |writePosition| is larger than |oldSize|,
         [=/reject=] |p| with a {{InvalidStateError}} and abort.

         Issue: Not clear if this should reject, and if it does, is this really the right error type?
         Chrome's implementation is actually inconsistent about this rejecting or not.

      1. If |data| is a {{BufferSource}},
         let |dataBytes| be [=get a copy of the buffer source|a copy of=] |data|.
      1. Else if |data| is a {{Blob}}:
         1. Let |dataBytes| be the result of performing the
            <a spec=FileAPI>read operation</a> on |data|.
            If this throws an exception, [=/reject=] |p| with that exception and abort.
      1. Else:
         1. [=Assert=]: |data| is a {{USVString}}.
         1. Let |dataBytes| be the result of [=UTF-8 encoding=] |data|.

      1. Let |head| be a [=byte sequence=] containing the first |writePosition| bytes of |stream|.[=[[buffer]]=].
      1. Let |tail| be an empty [=byte sequence=].
      1. If |writePosition| + |data|.[=byte sequence/length=] is smaller than |oldSize|:
         1. Let |tail| be a [=byte sequence=] containing the last
            |oldSize| - (|writePosition| + |data|.[=byte sequence/length=]) bytes of |stream|.[=[[buffer]]=].
      1. Set |stream|.[=[[buffer]]=] to the concatenation of |head|, |data| and |tail|.
      1. Set |stream|.[=[[seekOffset]]=] to |writePosition| + |data|.[=byte sequence/length=].
      1. [=/Resolve=] |p|.
   1. Else if |command| is {{WriteCommandType/"seek"}}:
      1. If |chunk|.{{WriteParams/position}} is `undefined`,
         [=/reject=] |p| with a {{TypeError}} and abort.
      1. Set |stream|.[=[[seekOffset]]=] to |chunk|.{{WriteParams/position}}.
      1. [=/Resolve=] |p|.
   1. Else if |command| is {{WriteCommandType/"truncate"}}:
      1. If |chunk|.{{WriteParams/size}} is `undefined`,
         [=/reject=] |p| with a {{TypeError}} and abort.
      1. Let |newSize| be |chunk|.{{WriteParams/size}}.
      1. Let |oldSize| be |stream|.[=[[buffer]]=]'s [=byte sequence/length=].
      1. If |newSize| is larger than |oldSize|:
         1. Set |stream|.[=[[buffer]]=] to a [=byte sequence=] formed by concating
            |stream|.[=[[buffer]]=] with a [=byte sequence=] containing |newSize|-|oldSize| `0x00` bytes.
      1. Else if |newSize| is smaller than |oldSize|:
         1. Set |stream|.[=[[buffer]]=] to a [=byte sequence=] containing the first |newSize| bytes
            in |stream|.[=[[buffer]]=].
      1. If |stream|.[=[[seekOffset]]=] is bigger than |newSize|,
         set |stream|.[=[[seekOffset]]=] to |newSize|.
      1. [=/Resolve=] |p|.
1. Return |p|.

</div>

### The {{FileSystemWritableFileStream/write()}} method ### {#api-filesystemwritablefilestream-write}

<div class="note domintro">
  : await |stream| . {{FileSystemWritableFileStream/write()|write}}(|data|)
  : await |stream| . {{FileSystemWritableFileStream/write()|write}}({
      {{WriteParams/type}}: {{WriteCommandType/"write"}},
      {{WriteParams/data}}: |data| })
  :: Writes the content of |data| into the file associated with |stream| at the current file
     cursor offset.

     No changes are written to the actual file on disk until the stream has been closed.
     Changes are typically written to a temporary file instead.

  : await |stream| . {{FileSystemWritableFileStream/write()|write}}({
      {{WriteParams/type}}: {{WriteCommandType/"write"}},
      {{WriteParams/position}}: |position|,
      {{WriteParams/data}}: |data| })
  :: Writes the content of |data| into the file associated with |stream| at |position|
     bytes from the top of the file. Also updates the current file cursor offset to the
     end of the written data.

     No changes are written to the actual file on disk until the stream has been closed.
     Changes are typically written to a temporary file instead.

  : await |stream| . {{FileSystemWritableFileStream/write()|write}}({
      {{WriteParams/type}}: {{WriteCommandType/"seek"}},
      {{WriteParams/position}}: |position| })
  :: Updates the current file cursor offset the |position| bytes from the top of the file.

  : await |stream| . {{FileSystemWritableFileStream/write()|write}}({
      {{WriteParams/type}}: {{WriteCommandType/"truncate"}},
      {{WriteParams/size}}: |size| })
  :: Resizes the file associated with |stream| to be |size| bytes long. If |size| is larger than
     the current file size this pads the file with null bytes, otherwise it truncates the file.

     The file cursor is updated when {{truncate}} is called. If the offset is smaller than offset,
     it remains unchanged. If the offset is larger than |size|, the offset is set to |size| to
     ensure that subsequent writes do not error.

     No changes are written to the actual file until on disk until the stream has been closed.
     Changes are typically written to a temporary file instead.
</div>

<div algorithm>
The <dfn method for=FileSystemWritableFileStream>write(|data|)</dfn> method, when invoked, must run
these steps:

1. Let |writer| be the result of calling [$AcquireWritableStreamDefaultWriter$](<b>[=this=]</b>).
1. Let |result| be [$WritableStreamDefaultWriterWrite$](|writer|, |data|).
1. Perform [$WritableStreamDefaultWriterRelease$](|writer|).
1. Return |result|.

</div>

### The {{FileSystemWritableFileStream/seek()}} method ### {#api-filesystemwritablefilestream-seek}

<div class="note domintro">
  : await |stream| . {{FileSystemWritableFileStream/seek()|seek}}(|position|)
  :: Updates the current file cursor offset the |position| bytes from the top of the file.
</div>

<div algorithm>
The <dfn method for=FileSystemWritableFileStream>seek(|position|)</dfn> method, when invoked, must run these
steps:

1. Let |writer| be the result of calling [$AcquireWritableStreamDefaultWriter$](<b>[=this=]</b>).
1. Let |result| be [$WritableStreamDefaultWriterWrite$](|writer|,
   <code>{<l>{{WriteParams/type}}</l>: {{WriteCommandType/"seek"}},
   <l>{{WriteParams/position}}</l>: |position|,
   <l>{{WriteParams/size}}</l>: undefined, <l>{{WriteParams/data}}</l>: undefined}</code>).
1. Perform [$WritableStreamDefaultWriterRelease$](|writer|).
1. Return |result|.

</div>

### The {{FileSystemWritableFileStream/truncate()}} method ### {#api-filesystemwritablefilestream-truncate}

<div class="note domintro">
  : await |stream| . {{FileSystemWritableFileStream/truncate()|truncate}}(|size|)
  :: Resizes the file associated with |stream| to be |size| bytes long. If |size| is larger than
     the current file size this pads the file with null bytes, otherwise it truncates the file.

     The file cursor is updated when {{truncate}} is called. If the offset is smaller than offset,
     it remains unchanged. If the offset is larger than |size|, the offset is set to |size| to
     ensure that subsequent writes do not error.

     No changes are written to the actual file until on disk until the stream has been closed.
     Changes are typically written to a temporary file instead.
</div>

<div algorithm>
The <dfn method for=FileSystemWritableFileStream>truncate(|size|)</dfn> method, when invoked, must run these
steps:

1. Let |writer| be the result of calling [$AcquireWritableStreamDefaultWriter$](<b>[=this=]</b>).
1. Let |result| be [$WritableStreamDefaultWriterWrite$](|writer|,
   <code>{<l>{{WriteParams/type}}</l>: {{WriteCommandType/"truncate"}},
   <l>{{WriteParams/size}}</l>: |size|,
   <l>{{WriteParams/position}}</l>: undefined, <l>{{WriteParams/data}}</l>: undefined}</code>).
1. Perform [$WritableStreamDefaultWriterRelease$](|writer|).
1. Return |result|.

</div>

# Accessing Native File System # {#native-filesystem}

## Native File System Permissions ## {#native-file-system-permissions}

<div algorithm>
The <dfn>native file system query permission steps</dfn> for an [=/entry=] |entry|
given a {{FileSystemHandlePermissionDescriptor}} |descriptor| are:

1. If |descriptor|.{{FileSystemHandlePermissionDescriptor/writable}} is true:
   1. Let |readState| be the result of running the [=query permission steps=] for |entry|
      given «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `false`&nbsp;]».
   1. If |readState| is not {{PermissionState/"granted"}}, return |readState|.
1. Let |settings| be the [=current settings object=].
1. If there was a previous invocation of this algorithm for the same |entry|, |descriptor|
   and |settings|, returning |previousResult|, and the UA has not received
   [=new information about the user's intent=] since that invocation, return |previousResult|.
1. Return whichever of the following options most accurately reflects the user's
   intent for the calling algorithm:
   <dl class="switch">
     : succeed without prompting the user
     :: {{PermissionState/"granted"}}

     : show the user a prompt to decide whether to succeed
     :: {{PermissionState/"prompt"}}

     : fail without prompting the user
     :: {{PermissionState/"denied"}}
   </dl>

</div>

<div algorithm>
The <dfn>native file system request permission steps</dfn> for an [=/entry=] |entry|
given a {{FileSystemHandlePermissionDescriptor}} |descriptor| are:

1. Let |status| be the result of running the [=query permission steps=] for |entry| given |descriptor|.
1. If |status| is not {{PermissionState/"prompt"}} return.
1. If the [=current global object=] is not a {{Window}},
   return.

   Issue: Should this throw instead of returning silently?

1. If the [=current global object=] does not have [=transient activation=], throw a {{NotAllowedError}}.
1. Let |environment| be the [=current settings object=].
1. If |environment|'s [=environment settings object/origin=] is not [=same origin=] with |environment|'s [=top-level origin=],
   throw a {{NotAllowedError}}.
1. Display a prompt to the user requesting access as described by |descriptor| to |entry|.
1. Wait for the user to accept or reject the prompt.
   The user's interaction may provide [=new information about the user's intent=]
   for this |descriptor| and |entry|.
   Additionally if |descriptor|.{{FileSystemHandlePermissionDescriptor/writable}} is true,
   the user's interaction may also provide [=new information about the user's intent=] for
   the same |entry| with «[&nbsp;"{{FileSystemHandlePermissionDescriptor/writable}}" → `false`&nbsp;]».

Note: This is intentionally vague about the details of the permission UI and how the UA infers user intent.
UAs <span class=allow-2119>should</span> be able to explore a variety of UI approaches within this framework.

</div>

## The {{Window/chooseFileSystemEntries()}} method ## {#api-choosefilesystementries}

<xmp class=idl>
enum ChooseFileSystemEntriesType { "open-file", "save-file", "open-directory" };

dictionary ChooseFileSystemEntriesOptionsAccepts {
  USVString description;
  sequence<USVString> mimeTypes;
  sequence<USVString> extensions;
};

dictionary ChooseFileSystemEntriesOptions {
    ChooseFileSystemEntriesType type = "open-file";
    boolean multiple = false;
    sequence<ChooseFileSystemEntriesOptionsAccepts> accepts;
    boolean excludeAcceptAllOption = false;
};

[SecureContext]
partial interface Window {
    Promise<(FileSystemHandle or sequence<FileSystemHandle>)>
        chooseFileSystemEntries(optional ChooseFileSystemEntriesOptions options = {});
};
</xmp>

<div class="note domintro">
  : |result| = await window . {{Window/chooseFileSystemEntries()|chooseFileSystemEntries}}(|options|)
  :: Shows a file picker dialog to the user and returns handles for the selected files or
     directories.

     The |options| argument sets options that influence the behavior of the shown file picker.

     |options|.{{ChooseFileSystemEntriesOptions/type}} specifies the type of the entry the website
     wants the user to pick.
     When set to {{ChooseFileSystemEntriesType/"open-file"}} (the default), the user can select only
     existing files.
     When set to {{ChooseFileSystemEntriesType/"save-file"}} the dialog will additionally let the
     user select files that don't yet exist, and if the user selects a file that does exist already,
     its contents will be cleared before the handle is returned to the website.
     Finally when set to {{ChooseFileSystemEntriesType/"open-directory"}}, the dialog will let the
     user select directories instead of files.

     If |options|.{{ChooseFileSystemEntriesOptions/multiple}} is false (or absent) the user can
     only select a single file, and the |result| will be a single {{FileSystemHandle}}. If on the
     other hand |options|.{{ChooseFileSystemEntriesOptions/multiple}} is true, the dialog can let
     the user select more than one file, and |result| will be an array of {{FileSystemHandle}}
     instances (even if the user did select a single file, if
     {{ChooseFileSystemEntriesOptions/multiple}} is true this will be returned as a single-element
     array).

     Finally |options|.{{ChooseFileSystemEntriesOptions/accepts}} and
     |options|.{{ChooseFileSystemEntriesOptions/excludeAcceptAllOption}} specify the types of files
     the dialog will let the user select. Each entry in
     |options|.{{ChooseFileSystemEntriesOptions/accepts}} describes a single type of file,
     consisting of a {{ChooseFileSystemEntriesOptionsAccepts/description}}, zero or more
     {{ChooseFileSystemEntriesOptionsAccepts/mimeTypes}} and zero or more
     {{ChooseFileSystemEntriesOptionsAccepts/extensions}}. Options with no valid
     {{ChooseFileSystemEntriesOptionsAccepts/mimeTypes}} and no
     {{ChooseFileSystemEntriesOptionsAccepts/extensions}} are invalid and are ignored. If no
     {{ChooseFileSystemEntriesOptionsAccepts/description}} is provided one will be generated.

     If |options|.{{ChooseFileSystemEntriesOptions/excludeAcceptAllOption}} is true, or if no valid
     entries exist in |options|.{{ChooseFileSystemEntriesOptions/accepts}}, an option matching all
     files will be included in the file types the dialog lets the user select.
</div>

<div algorithm>
The <dfn method for=Window>chooseFileSystemEntries(|options|)</dfn> method, when invoked, must run
these steps:

1. Let |environment| be the [=current settings object=].

1. If |environment|'s [=environment settings object/origin=] is an [=opaque origin=],
   return [=a promise rejected with=] a {{SecurityError}}.

1. Let |browsing context| be |environment|'s [=responsible browsing context=].

1. Let |top-level context| be |browsing context|'s [=top-level browsing context=].

1. If |environment|'s [=environment settings object/origin=] is not [=same origin=] with |browsing context|'s [=top-level browsing context=]'s [=active document=]'s  [=/origin=],
   return [=a promise rejected with=] a {{SecurityError}}.

   Issue: There must be a better way to express this "no third-party iframes" constraint.

1. TODO (Use the [=native file system query permission steps=] and
   [=native file system request permission steps=] in the returned entries).

</div>

# Accessing special file systems # {#special-filesystems}

## Special File System Concepts ## {#special-filesystem-concepts}

A [=bucket=] contains a <dfn>sandboxed file system root</dfn>, a [=directory entry=].

The [=sandboxed file system root=] for one [=bucket=] must be completely separate from
that of any other [=bucket=].

Note: While user agents will typically implement this by persisting the contents of this
[=sandboxed file system root=] to disk, it is not intended that the contents are easily
user accessible. Similarly there is no expectation that files or directories with names
matching the names of children of the [=sandboxed file system root=] exist.

Note: In Chrome this [=sandboxed file system root=] refers to the same storage as the
<a href="https://dev.w3.org/2009/dap/file-system/file-dir-sys.html#dfn-temporary">temporary
file system</a> as used to be defined in [[file-system-api|File API: Directories and System]].

<div algorithm="sandbox-query-permission">
The [=sandboxed file system root=]'s [=query permission steps=] are the following:

1. Return {{PermissionState/"granted"}}.

</div>

## The {{FileSystemDirectoryHandle/getSystemDirectory()}} method ## {#api-getsystemdirectory}

<xmp class=idl>
enum SystemDirectoryType {
  "sandbox"
};

dictionary GetSystemDirectoryOptions {
  required SystemDirectoryType type;
};

[SecureContext]
partial interface FileSystemDirectoryHandle {
  static Promise<FileSystemDirectoryHandle> getSystemDirectory(GetSystemDirectoryOptions options);
};
</xmp>

<div class="note domintro">
  : |directoryHandle| = {{FileSystemDirectoryHandle}} .
    {{FileSystemDirectoryHandle/getSystemDirectory()|getSystemDirectory}}({
       {{GetSystemDirectoryOptions/type}}: {{SystemDirectoryType/"sandbox"}} })
  :: Returns the sandboxed file system.
</div>

Issue(27): getSystemDirectory might not be the best name. Also perhaps should be on Window rather
than on FileSystemDirectoryHandle.

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getSystemDirectory(|options|)</dfn> method, when
invoked, must run these steps:

1. Let |environment| be the [=current settings object=].

1. If |environment|'s [=environment settings object/origin=] is an [=opaque origin=],
   return [=a promise rejected with=] a {{SecurityError}}.

1. [=Assert=]: |options|.{{GetSystemDirectoryOptions/type}} is {{SystemDirectoryType/"sandbox"}}.
1. Let |storage| be |environment|'s [=environment settings object/origin=]'s [=site storage unit=].
1. Let |bucket| be |storage|'s [=bucket=].
1. Return [=a promise resolved with=] a new {{FileSystemDirectoryHandle}},
   whose associated [=FileSystemHandle/entry=] is |bucket|'s [=sandboxed file system root=].

</div>

# Privacy Considerations # {#privacy-considerations}

*This section is non-normative.*

This API does not give websites any more read access to data than the existing `<input type=file>`
and `<input type=file webkitdirectory>` APIs already do. Furthermore similarly to those APIs, all
access to files and directories is explicitly gated behind a file or directory picker.

There are however several major privacy risks with this new API:

## Users giving access to more, or more sensitive files than they intended. ## {#privacy-wide-access}

This isn't a new risk with this API, but user agents should try to make sure that users are aware
of what exactly they're giving websites access to. This is particularly important when giving
access to a directory, where it might not be immediately clear to a user just how many files
actually exist in that directory.

A related risk is having a user give access to particularly sensitive data. This
could include some of a user agent's configuration data, network cache or cookie store,
or operating system configuration data such as password files. To protect against this, user agents
are encouraged to restrict which directories a user is allowed to select in a directory picker,
and potentially even restrict which files the user is allowed to select. This will make it much
harder to accidentally give access to a directory that contains particularly sensitive data. Care
must be taken to strike the right balance between restricting what the API can access while still
having the API be useful. After all, this API intentionally lets the user use websites to interact
with some of their most private personal data.

## Websites trying to use this API for tracking. ## {#privacy-tracking}

This API could be used by websites to track the user across clearing browsing
data. This is because, in contrast with existing file access APIs, user agents are
able to grant persistent access to files or directories and can re-prompt. In
combination with the ability to write to files, websites will be able to persist an
identifier on the users' disk. Clearing browsing data will not affect those files
in any way, making these identifiers persist through those actions.

This risk is somewhat mitigated by the fact that clearing browsing data will also clear IndexedDB,
so websites won't have any handles to re-prompt for permission after browsing data was cleared.
Furthermore user agents are encouraged to make it clear what files and directories a website has
access to, and to automatically expire permission grants except for particularly well trusted
origins (for example persistent permissions could be limited to "installed" web applications).

User agents also are encouraged to provide a way for users to revoke permissions granted.
Clearing browsing data is expected to revoke all permissions as well.

## First-party vs third-party contexts. ## {#privacy-third-party}

In third-party contexts (e.g. an iframe whose origin does not match that of the top-level frame)
websites can't gain access to data they don't already have access to. This includes both getting
access to new files or directories via the {{chooseFileSystemEntries}} API, as well as requesting
more permissions to existing handles via the {{requestPermission}} API.

Handles can also only be post-messaged to same-origin destinations. Attempts to send a handle to
a cross-origin destination will result in a {{MessagePort/messageerror}} event.

# Security Considerations # {#security-considerations}

*This section is non-normative.*

This API gives websites the ability to modify existing files on disk, as well as write to new
files. This has a couple of important security considerations:

## Malware ## {#security-malware}

This API could be used by websites to try to store and/or execute malware on the users system.
To mitigate this risk, this API does not provide any way to mark files as executable (on the other
hand files that are already executable likely remain that way, even after the files are modified
through this API). Furthermore user agents are encouraged to apply things like Mark-of-the-Web to
files created or modified by this API.

Finally, user agents are encouraged to verify the contents of files modified by this API via malware
scans and safe browsing checks, unless some kind of external strong trust relation already exists.
This of course has effects on the performance characteristics of this API.

Issue(51): "Atomic writes" attempts to make it explicit what this API can and can't do, and how
performance can be effected by safe browsing checks.

## Ransomware attacks ## {#security-ransomware}

Another risk factor is that of ransomware attacks. The limitations described above regarding
blocking access to certain sensitive directories helps limit the damage such an attack can do.
Additionally user agents can grant write access to files at whatever granularity they deem
appropriate.
